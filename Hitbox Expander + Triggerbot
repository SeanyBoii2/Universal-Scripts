--[[
    ================================================================
    =                   SPOOKALICIOUS V4                           =
    =              HITBOX EXPANDER + TRIGGERBOT                    =
    ================================================================
--]]

--================================--
--          SERVICES              --
--================================--
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local player = Players.LocalPlayer

--================================--
--         LOAD LIBRARY           --
--================================--
print("[SPOOKALICIOUS] Loading Spookalicious V4 library...")

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/SeanyBoii2/Z/refs/heads/main/SPOOKALICIOUS%20V4%20API/SpookaliciousV4.lua"))()

print("[SPOOKALICIOUS] Loading addons...")

local ConfigSystem = loadstring(game:HttpGet("https://raw.githubusercontent.com/SeanyBoii2/Z/refs/heads/main/SPOOKALICIOUS%20V4%20API/ConfigSystem_Addon.lua"))()
local NewElements = loadstring(game:HttpGet("https://raw.githubusercontent.com/SeanyBoii2/Z/refs/heads/main/SPOOKALICIOUS%20V4%20API/NewElements_Addon.lua"))()

print("[SPOOKALICIOUS] Addons loaded!")

--================================--
--   EXTEND & CREATE WINDOW       --
--================================--
NewElements.Extend(Library)

local Window = Library:CreateWindow("SPOOKALICIOUS", "V4")

ConfigSystem:Attach(Window)
Window:SetAutoSave(false)

Window:Notify("Hitbox Expander + TriggerBot Loaded!")

--================================--
--       SHARED HELPERS           --
--================================--

-- Thorough alive check: covers humanoid state, health, ragdoll tags, and common death indicators
local function isAlive(character)
    if not character or not character.Parent then return false end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    if humanoid.Health <= 0 then return false end

    local hState = humanoid:GetState()
    if hState == Enum.HumanoidStateType.Dead then return false end
    if hState == Enum.HumanoidStateType.Physics then return false end

    -- Common ragdoll/death tags used by many games
    if character:FindFirstChild("Ragdoll") then return false end
    if character:FindFirstChild("Ragdolled") then return false end
    if character:FindFirstChild("Dead") then return false end
    if character:FindFirstChild("IsDead") then return false end

    -- Check BoolValue/StringValue death markers
    local deadVal = character:FindFirstChild("isDead") or character:FindFirstChild("IsDead")
    if deadVal and typeof(deadVal.Value) == "boolean" and deadVal.Value == true then return false end

    -- No HumanoidRootPart usually means dead/despawning
    if not character:FindFirstChild("HumanoidRootPart") then
        -- Some custom models don't use HRP, so only fail if they DO have a humanoid (standard char)
        if Players:GetPlayerFromCharacter(character) then
            return false
        end
    end

    return true
end

-- Lightweight alive check for the triggerbot hot path (skips expensive lookups)
local function isAliveFast(character)
    if not character or not character.Parent then return false end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    if humanoid.Health <= 0 then return false end

    local hState = humanoid:GetState()
    if hState == Enum.HumanoidStateType.Dead or hState == Enum.HumanoidStateType.Physics then
        return false
    end

    return true
end

-- Check for dead custom models that may not have a standard humanoid state
local function isDeadCustomModel(model)
    if not model or not model.Parent then return true end

    -- Check for humanoid first
    local humanoid = model:FindFirstChildOfClass("Humanoid")
    if humanoid then
        if humanoid.Health <= 0 then return true end
        local hState = humanoid:GetState()
        if hState == Enum.HumanoidStateType.Dead or hState == Enum.HumanoidStateType.Physics then
            return true
        end
    end

    -- Common death/ragdoll markers
    if model:FindFirstChild("Ragdoll") or model:FindFirstChild("Ragdolled") then return true end
    if model:FindFirstChild("Dead") or model:FindFirstChild("IsDead") then return true end

    local deadVal = model:FindFirstChild("isDead") or model:FindFirstChild("IsDead")
    if deadVal and typeof(deadVal.Value) == "boolean" and deadVal.Value == true then return true end

    return false
end

local function isTeammate(model)
    local plr = Players:GetPlayerFromCharacter(model)
    if not plr then return false end
    if player.Team and plr.Team and player.Team == plr.Team then return true end
    if player.TeamColor ~= BrickColor.new("White") and plr.TeamColor == player.TeamColor then return true end
    if not player.Neutral and not plr.Neutral and player.Team == plr.Team then return true end
    return false
end

-- Team check using a player object directly (for custom models)
local function isTeammatePlayer(plr)
    if not plr then return false end
    if player.Team and plr.Team and player.Team == plr.Team then return true end
    if player.TeamColor ~= BrickColor.new("White") and plr.TeamColor == player.TeamColor then return true end
    if not player.Neutral and not plr.Neutral and player.Team == plr.Team then return true end
    return false
end

--================================--
--   HITBOX EXPANDER VARIABLES    --
--================================--
local HitboxSettings = {
    Enabled = false,
    HitboxSize = 8,
    Radius = 150,
    TargetMode = "NPCs",
    HitboxPartName = "Head",
    Transparency = 0.99,
    Material = Enum.Material.Neon,
    Color = BrickColor.new("Really blue"),
    PartsPerStep = 25,
    ApplyTransparency = true,
    ApplyMaterial = true,
    ApplyColor = true,
    ApplyCanCollide = true,
    ApplyMassless = true
}

local editedCharacters = {}
local originalHitboxData = {}

--================================--
--   HITBOX EXPANDER LOGIC        --
--================================--
local overlapParams = OverlapParams.new()
overlapParams.FilterType = Enum.RaycastFilterType.Blacklist

local function isValidTarget(character)
    if not isAlive(character) then return false end
    if isTeammate(character) then return false end

    local playerFromChar = Players:GetPlayerFromCharacter(character)
    if HitboxSettings.TargetMode == "Players" then
        return playerFromChar and playerFromChar ~= player
    elseif HitboxSettings.TargetMode == "NPCs" then
        return not playerFromChar
    elseif HitboxSettings.TargetMode == "Both" then
        return not playerFromChar or playerFromChar ~= player
    end
end

local function applyHitbox(character)
    if editedCharacters[character] then return end
    if not isValidTarget(character) then return end

    local hitbox = character:FindFirstChild(HitboxSettings.HitboxPartName)
    if not hitbox then return end

    if not originalHitboxData[hitbox] then
        originalHitboxData[hitbox] = {
            Size = hitbox.Size,
            Transparency = hitbox.Transparency,
            Material = hitbox.Material,
            BrickColor = hitbox.BrickColor,
            CanCollide = hitbox.CanCollide,
            Massless = hitbox.Massless
        }
    end

    editedCharacters[character] = true

    for _, child in ipairs(hitbox:GetChildren()) do
        if child:IsA("Decal") or child:IsA("Texture") then
            child:Destroy()
        end
    end

    hitbox.Size = Vector3.new(HitboxSettings.HitboxSize, HitboxSettings.HitboxSize, HitboxSettings.HitboxSize)

    if HitboxSettings.ApplyTransparency then
        hitbox.Transparency = HitboxSettings.Transparency
    end
    if HitboxSettings.ApplyMaterial then
        hitbox.Material = HitboxSettings.Material
    end
    if HitboxSettings.ApplyColor then
        hitbox.BrickColor = HitboxSettings.Color
    end
    if HitboxSettings.ApplyCanCollide then
        hitbox.CanCollide = false
    end
    if HitboxSettings.ApplyMassless then
        hitbox.Massless = true
    end
end

local function restoreAllHitboxes()
    for hitbox, originalData in pairs(originalHitboxData) do
        if hitbox and hitbox.Parent then
            hitbox.Size = originalData.Size
            hitbox.Transparency = originalData.Transparency
            hitbox.Material = originalData.Material
            hitbox.BrickColor = originalData.BrickColor
            hitbox.CanCollide = originalData.CanCollide
            hitbox.Massless = originalData.Massless
        end
    end
    editedCharacters = {}
    originalHitboxData = {}
end

task.spawn(function()
    while task.wait(0.1) do
        if not HitboxSettings.Enabled then continue end

        for character, _ in pairs(editedCharacters) do
            if not character or not character.Parent or not isAlive(character) then
                local hitbox = character and character:FindFirstChild(HitboxSettings.HitboxPartName)
                if hitbox and originalHitboxData[hitbox] then
                    local orig = originalHitboxData[hitbox]
                    if hitbox.Parent then
                        hitbox.Size = orig.Size
                        hitbox.Transparency = orig.Transparency
                        hitbox.Material = orig.Material
                        hitbox.BrickColor = orig.BrickColor
                        hitbox.CanCollide = orig.CanCollide
                        hitbox.Massless = orig.Massless
                    end
                    originalHitboxData[hitbox] = nil
                end
                editedCharacters[character] = nil
            end
        end

        local character = player.Character
        local hrp = character and character:FindFirstChild("HumanoidRootPart")

        if hrp then
            overlapParams.FilterDescendantsInstances = { character }
            local parts = Workspace:GetPartBoundsInRadius(hrp.Position, HitboxSettings.Radius, overlapParams)

            local processed = 0
            for i = 1, #parts do
                local model = parts[i]:FindFirstAncestorOfClass("Model")
                if model and model:FindFirstChildOfClass("Humanoid") then
                    applyHitbox(model)
                end

                processed += 1
                if processed % HitboxSettings.PartsPerStep == 0 then
                    task.wait()
                end
            end
        end
    end
end)

--================================--
--      TRIGGERBOT VARIABLES      --
--================================--
_G.config = _G.config or {
    HoldClick = true,
    TeamExclusionMode = "folder",
    MaxDistance = nil
}

_G.TriggerBotState = _G.TriggerBotState or { clicking = false }
local state = _G.TriggerBotState

local mouse = player:GetMouse()

local rightDown = false
UserInputService.InputBegan:Connect(function(i)
    if i.UserInputType == Enum.UserInputType.MouseButton2 then rightDown = true end
end)
UserInputService.InputEnded:Connect(function(i)
    if i.UserInputType == Enum.UserInputType.MouseButton2 then rightDown = false end
end)

local lastX, lastY = 0, 0
RunService.RenderStepped:Connect(function()
    local v = UserInputService:GetMouseLocation()
    lastX, lastY = v.X, v.Y
end)

local clickDelay = 0
local lastClickTime = 0

local function setClick(down)
    if state.clicking == down then return end
    state.clicking = down
    VirtualInputManager:SendMouseButtonEvent(lastX, lastY, 0, down, nil, 0)
end

local function spamClick()
    local now = tick()
    if now - lastClickTime < clickDelay then return end
    lastClickTime = now
    VirtualInputManager:SendMouseButtonEvent(lastX, lastY, 0, true, nil, 0)
    VirtualInputManager:SendMouseButtonEvent(lastX, lastY, 0, false, nil, 0)
end

local function inRange(model)
    local max = _G.config.MaxDistance
    if not max then return true end
    local char = player.Character
    if not char then return false end
    local root1 = char:FindFirstChild("HumanoidRootPart")
    if not root1 then return false end

    local root2 = model:FindFirstChild("HumanoidRootPart")
    if not root2 then
        for _, part in ipairs(model:GetChildren()) do
            if part:IsA("BasePart") then
                root2 = part
                break
            end
        end
    end
    if not root2 then return false end
    return (root1.Position - root2.Position).Magnitude <= max
end

local function isMyCharacter(model)
    return model == player.Character
end

local function isInSameParentContainer(model)
    local char = player.Character
    if not char then return false end
    return model:IsDescendantOf(char.Parent)
end

local modelCache = setmetatable({}, { __mode = "k" })

local function getCharacterModel(part)
    if not part then return end
    if modelCache[part] then return modelCache[part] end

    local current = part
    while current and current ~= Workspace do
        if current:IsA("Model") and current:FindFirstChildOfClass("Humanoid") then
            modelCache[part] = current
            return current
        end
        current = current.Parent
    end
end

--============================================================--
--  PLAYER MODEL RESOLVER (EVENT-DRIVEN, NO LAG)              --
--  Instead of scanning all of workspace every 0.5s, we:      --
--  1. Build a name lookup from the player list (lightweight)  --
--  2. Listen to ChildAdded/Removed on workspace (one-time)   --
--  3. Listen to PlayerAdded/Removing to update the name map   --
--  4. Only register models when they appear, not by looping   --
--============================================================--

-- modelToPlayer: Model -> Player (weak keys for auto-cleanup)
local modelToPlayer = setmetatable({}, { __mode = "k" })

-- playerNameSet: lowercase name -> Player (rebuilt only when player list changes)
local playerNameSet = {}
local nameSetDirty = true

local function rebuildNameSet()
    playerNameSet = {}
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= player then
            playerNameSet[plr.Name:lower()] = plr
            if plr.DisplayName and #plr.DisplayName > 0 and plr.DisplayName ~= plr.Name then
                playerNameSet[plr.DisplayName:lower()] = plr
            end
            -- Always map standard character
            if plr.Character then
                modelToPlayer[plr.Character] = plr
            end
        end
    end
    nameSetDirty = false
end

-- Try to register a single model if its name matches a player
local function tryRegisterModel(instance)
    if not instance:IsA("Model") then return end
    if nameSetDirty then rebuildNameSet() end

    local ownerPlayer = playerNameSet[instance.Name:lower()]
    if ownerPlayer then
        modelToPlayer[instance] = ownerPlayer
    end
end

-- Unregister a model when removed
local function tryUnregisterModel(instance)
    if instance:IsA("Model") then
        modelToPlayer[instance] = nil
    end
end

-- ═══ EVENT HOOKS (fire only when things change, zero polling cost) ═══

-- When a new child is added to workspace, check if it's a player model
Workspace.ChildAdded:Connect(tryRegisterModel)
Workspace.ChildRemoved:Connect(tryUnregisterModel)

-- Also watch DescendantAdded for models inside folders (1 event, not a loop)
Workspace.DescendantAdded:Connect(function(desc)
    if desc:IsA("Model") then
        tryRegisterModel(desc)
    end
end)

Workspace.DescendantRemoving:Connect(function(desc)
    if desc:IsA("Model") then
        modelToPlayer[desc] = nil
    end
end)

-- When players join/leave, mark name set dirty and re-register characters
Players.PlayerAdded:Connect(function(plr)
    nameSetDirty = true
    plr.CharacterAdded:Connect(function(char)
        modelToPlayer[char] = plr
    end)
end)

Players.PlayerRemoving:Connect(function(plr)
    nameSetDirty = true
    -- Clean up any models belonging to this player
    for model, owner in pairs(modelToPlayer) do
        if owner == plr then
            modelToPlayer[model] = nil
        end
    end
end)

-- Hook existing players' CharacterAdded
for _, plr in ipairs(Players:GetPlayers()) do
    if plr ~= player then
        plr.CharacterAdded:Connect(function(char)
            modelToPlayer[char] = plr
        end)
    end
end

-- Initial registration: one-time scan of existing workspace children (not recursive heavy scan)
task.defer(function()
    rebuildNameSet()
    -- Quick pass over workspace direct children + one level deep in folders
    for _, child in ipairs(Workspace:GetChildren()) do
        tryRegisterModel(child)
        if child:IsA("Folder") then
            for _, sub in ipairs(child:GetChildren()) do
                tryRegisterModel(sub)
            end
        end
    end
end)

-- Walk up from a part and check if any ancestor model is owned by another player
local function getOwningPlayerModel(part)
    if not part then return nil, nil end

    local current = part
    while current and current ~= Workspace do
        if current:IsA("Model") then
            local ownerPlayer = modelToPlayer[current]
            if ownerPlayer then
                return current, ownerPlayer
            end
        end
        current = current.Parent
    end
    return nil, nil
end

--============================================================--
--  COMBINED TARGET VALIDATION                                --
--============================================================--

local function getValidTarget(part)
    if not part then return false end

    -- ═══ CHECK 1: Classic humanoid-based detection ═══
    local model = getCharacterModel(part)
    if model then
        if isMyCharacter(model) then return false end
        if not inRange(model) then return false end
        if not isAliveFast(model) then return false end

        -- Extra dead checks
        if model:FindFirstChild("Ragdoll") or model:FindFirstChild("Ragdolled") then return false end
        if model:FindFirstChild("Dead") or model:FindFirstChild("IsDead") then return false end
        if not model:FindFirstChild("HumanoidRootPart") and Players:GetPlayerFromCharacter(model) then return false end

        local mode = _G.config.TeamExclusionMode
        if mode == "team" and isTeammate(model) then return false end
        if mode == "folder" and isInSameParentContainer(model) then return false end
        if mode == "players" and Players:GetPlayerFromCharacter(model) then return false end

        local humanoid = model:FindFirstChildOfClass("Humanoid")
        if humanoid then
            return true
        end
    end

    -- ═══ CHECK 2: Player model resolver (custom character models) ═══
    local playerModel, ownerPlayer = getOwningPlayerModel(part)
    if playerModel and ownerPlayer then
        if ownerPlayer == player then return false end
        if isMyCharacter(playerModel) then return false end
        if not inRange(playerModel) then return false end

        -- Dead check for custom models
        if isDeadCustomModel(playerModel) then return false end

        -- Team exclusion using the resolved player object
        local mode = _G.config.TeamExclusionMode
        if mode == "team" and isTeammatePlayer(ownerPlayer) then return false end
        if mode == "folder" and isInSameParentContainer(playerModel) then return false end

        return true
    end

    return false
end

-- Main TriggerBot loop
local triggerBotEnabled = false
RunService.RenderStepped:Connect(function()
    if not triggerBotEnabled then
        if state.clicking then setClick(false) end
        return
    end
    if _G.config.HoldClick and not rightDown then
        if state.clicking then setClick(false) end
        return
    end
    if getValidTarget(mouse.Target) then
        spamClick()
    else
        if state.clicking then setClick(false) end
    end
end)


--╔══════════════════════════════════════════════════════════════════════════╗
--║                     HITBOX EXPANDER GUI                                  ║
--╚══════════════════════════════════════════════════════════════════════════╝

local HitboxPage = Window:CreatePage("Hitbox Expander")

local MainSection = HitboxPage:CreateSection("Main Controls")

MainSection:CreateToggle("Enable Hitbox Expander", {Toggled = false}, function(value)
    HitboxSettings.Enabled = value
    if not value then
        restoreAllHitboxes()
    end
    Window:Notify("Hitbox Expander: " .. (value and "ACTIVE" or "INACTIVE"))
end)

local ConfigSection = HitboxPage:CreateSection("Hitbox Configuration")

ConfigSection:CreateSlider("Hitbox Size", {Min = 1, Max = 50, DefaultValue = 8, Step = 1}, function(value)
    HitboxSettings.HitboxSize = value
    restoreAllHitboxes()
end)

ConfigSection:CreateSlider("Detection Radius", {Min = 50, Max = 500, DefaultValue = 150, Step = 10}, function(value)
    HitboxSettings.Radius = value
end)

ConfigSection:CreateSlider("Transparency", {Min = 0, Max = 100, DefaultValue = 99, Step = 1}, function(value)
    HitboxSettings.Transparency = value / 100
    restoreAllHitboxes()
end)

local TargetSection = HitboxPage:CreateSection("Target Settings")

TargetSection:CreateButton("Target: NPCs Only", function()
    HitboxSettings.TargetMode = "NPCs"
    restoreAllHitboxes()
    Window:Notify("Target Mode: NPCs")
end)

TargetSection:CreateButton("Target: Players Only", function()
    HitboxSettings.TargetMode = "Players"
    restoreAllHitboxes()
    Window:Notify("Target Mode: Players")
end)

TargetSection:CreateButton("Target: Both NPCs & Players", function()
    HitboxSettings.TargetMode = "Both"
    restoreAllHitboxes()
    Window:Notify("Target Mode: Both")
end)

TargetSection:CreateTextbox("Hitbox Part Name", "Head", function(text)
    if text and #text > 0 then
        HitboxSettings.HitboxPartName = text
        restoreAllHitboxes()
        Window:Notify("Part Name: " .. text)
    end
end)

local PropertySection = HitboxPage:CreateSection("Property Toggles")

PropertySection:CreateToggle("Apply Transparency", {Toggled = true}, function(value)
    HitboxSettings.ApplyTransparency = value
    restoreAllHitboxes()
    Window:Notify("Apply Transparency: " .. (value and "ON" or "OFF"))
end)

PropertySection:CreateToggle("Apply Material", {Toggled = true}, function(value)
    HitboxSettings.ApplyMaterial = value
    restoreAllHitboxes()
    Window:Notify("Apply Material: " .. (value and "ON" or "OFF"))
end)

PropertySection:CreateToggle("Apply Color", {Toggled = true}, function(value)
    HitboxSettings.ApplyColor = value
    restoreAllHitboxes()
    Window:Notify("Apply Color: " .. (value and "ON" or "OFF"))
end)

PropertySection:CreateToggle("Apply CanCollide = False", {Toggled = true}, function(value)
    HitboxSettings.ApplyCanCollide = value
    restoreAllHitboxes()
    Window:Notify("Apply CanCollide: " .. (value and "ON" or "OFF"))
end)

PropertySection:CreateToggle("Apply Massless = True", {Toggled = true}, function(value)
    HitboxSettings.ApplyMassless = value
    restoreAllHitboxes()
    Window:Notify("Apply Massless: " .. (value and "ON" or "OFF"))
end)

local AdvancedSection = HitboxPage:CreateSection("Advanced Settings")

AdvancedSection:CreateSlider("Parts Per Step", {Min = 10, Max = 100, DefaultValue = 25, Step = 5}, function(value)
    HitboxSettings.PartsPerStep = value
end)

AdvancedSection:CreateButton("Reset All Hitboxes", function()
    restoreAllHitboxes()
    Window:Notify("All hitboxes restored!")
end)


--╔══════════════════════════════════════════════════════════════════════════╗
--║                        TRIGGERBOT GUI                                    ║
--╚══════════════════════════════════════════════════════════════════════════╝

local TriggerBotPage = Window:CreatePage("TriggerBot")

local TriggerMainSection = TriggerBotPage:CreateSection("Main Controls")

TriggerMainSection:CreateToggle("Enable TriggerBot", {Toggled = false}, function(value)
    triggerBotEnabled = value
    Window:Notify("TriggerBot: " .. (value and "ACTIVE" or "INACTIVE"))
end)

local TriggerConfigSection = TriggerBotPage:CreateSection("Configuration")

TriggerConfigSection:CreateToggle("Hold Click Mode", {Toggled = true}, function(value)
    _G.config.HoldClick = value
    Window:Notify("Hold Click: " .. (value and "ON" or "OFF"))
end)

TriggerConfigSection:CreateSlider("Click Speed (Lower = Faster)", {Min = 0, Max = 100, DefaultValue = 0, Step = 1}, function(value)
    clickDelay = value / 1000
    if value == 0 then
        Window:Notify("Click Speed: MAXIMUM")
    else
        Window:Notify("Click Delay: " .. value .. "ms")
    end
end)

TriggerConfigSection:CreateSlider("Max Distance", {Min = 0, Max = 500, DefaultValue = 0, Step = 10}, function(value)
    if value == 0 then
        _G.config.MaxDistance = nil
        Window:Notify("Max Distance: Unlimited")
    else
        _G.config.MaxDistance = value
        Window:Notify("Max Distance: " .. value .. " studs")
    end
end)

local TriggerTeamSection = TriggerBotPage:CreateSection("Team Exclusion")

TriggerTeamSection:CreateButton("Mode: Team Check", function()
    _G.config.TeamExclusionMode = "team"
    Window:Notify("Exclusion Mode: Team")
end)

TriggerTeamSection:CreateButton("Mode: Folder Check", function()
    _G.config.TeamExclusionMode = "folder"
    Window:Notify("Exclusion Mode: Folder")
end)

TriggerTeamSection:CreateButton("Mode: Exclude Players (NPCs Only)", function()
    _G.config.TeamExclusionMode = "players"
    Window:Notify("Exclusion Mode: Players (NPCs Only)")
end)

TriggerTeamSection:CreateButton("Mode: None (Shoot All)", function()
    _G.config.TeamExclusionMode = "none"
    Window:Notify("Exclusion Mode: None")
end)


--╔══════════════════════════════════════════════════════════════════════════╗
--║                           DONE                                           ║
--╚══════════════════════════════════════════════════════════════════════════╝

print("═══════════════════════════════════════════")
print("  SPOOKALICIOUS V4")
print("  Hitbox Expander + TriggerBot")
print("═══════════════════════════════════════════")
print("✓ Library loaded")
print("✓ Config system active")
print("✓ New elements active")
print("✓ Hitbox Expander ready")
print("✓ TriggerBot ready")
print("✓ Player model resolver (event-driven)")
print("═══════════════════════════════════════════")
