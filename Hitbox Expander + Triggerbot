--══════════════════════════════════════════════════════════════
--  AUTO-RELOAD ON TELEPORT
--══════════════════════════════════════════════════════════════

local HUB_URL = "https://raw.githubusercontent.com/SeanyBoii2/Universal-Scripts/refs/heads/main/Hitbox%20Expander%20%2B%20Triggerbot"

if HUB_URL ~= "" then
    local queueCode = 'loadstring(game:HttpGet("' .. HUB_URL .. '"))()'
    local success = pcall(function()
        if syn and syn.queue_on_teleport then
            syn.queue_on_teleport(queueCode)
        elseif queue_on_teleport then
            queue_on_teleport(queueCode)
        elseif fluxus and fluxus.queue_on_teleport then
            fluxus.queue_on_teleport(queueCode)
        end
    end)
    if success then
        print("[AUTO-RELOAD] Enabled for Solara")
    else
        print("[AUTO-RELOAD] Failed - executor may not support queue_on_teleport")
    end
end


--══════════════════════════════════════════════════════════════
--  LOAD LIBRARY
--══════════════════════════════════════════════════════════════

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/SeanyBoii2/Z/refs/heads/main/SPOOKALICIOUS%20V4%20API/SpookaliciousV4.lua"))()


--══════════════════════════════════════════════════════════════
--  CREATE WINDOW
--══════════════════════════════════════════════════════════════

local Window = Library:CreateWindow("MY HUB", "V1.0")


--══════════════════════════════════════════════════════════════
--  SERVICES
--══════════════════════════════════════════════════════════════

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local UIS = game:GetService("UserInputService")
local TeleportService = game:GetService("TeleportService")
local VirtualUser = game:GetService("VirtualUser")
local VirtualInputManager = game:GetService("VirtualInputManager")

local player = Players.LocalPlayer
local _hasFS = (typeof(writefile) == "function" and typeof(readfile) == "function")

local function sendNotification(title, text)
    for i = 1, 10 do
        local ok = pcall(function()
            StarterGui:SetCore("SendNotification", {
                Title = title, Text = text, Duration = 5,
            })
        end)
        if ok then break end
        task.wait(0.5)
    end
end

local functionalToggles = {}

local function registerFunctionalToggle(toggle, defaultState)
    table.insert(functionalToggles, { ref = toggle, default = defaultState or false })
end

local function resetFunctionalToggles()
    for _, item in ipairs(functionalToggles) do
        item.ref:Set(item.default)
    end
end


--══════════════════════════════════════════════════════════════
--  SHARED HELPERS
--══════════════════════════════════════════════════════════════

local function isAlive(character)
    if not character or not character.Parent then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    if humanoid.Health <= 0 then return false end
    local hState = humanoid:GetState()
    if hState == Enum.HumanoidStateType.Dead then return false end
    if hState == Enum.HumanoidStateType.Physics then return false end
    if character:FindFirstChild("Ragdoll") then return false end
    if character:FindFirstChild("Ragdolled") then return false end
    if character:FindFirstChild("Dead") then return false end
    if character:FindFirstChild("IsDead") then return false end
    local deadVal = character:FindFirstChild("isDead") or character:FindFirstChild("IsDead")
    if deadVal and typeof(deadVal.Value) == "boolean" and deadVal.Value == true then return false end
    if not character:FindFirstChild("HumanoidRootPart") and Players:GetPlayerFromCharacter(character) then
        return false
    end
    return true
end

local function isAliveFast(character)
    if not character or not character.Parent then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    local hState = humanoid:GetState()
    return hState ~= Enum.HumanoidStateType.Dead and hState ~= Enum.HumanoidStateType.Physics
end

local function isDeadCustomModel(model)
    if not model or not model.Parent then return true end
    local humanoid = model:FindFirstChildOfClass("Humanoid")
    if humanoid then
        if humanoid.Health <= 0 then return true end
        local hState = humanoid:GetState()
        if hState == Enum.HumanoidStateType.Dead or hState == Enum.HumanoidStateType.Physics then return true end
    end
    if model:FindFirstChild("Ragdoll") or model:FindFirstChild("Ragdolled") then return true end
    if model:FindFirstChild("Dead") or model:FindFirstChild("IsDead") then return true end
    local deadVal = model:FindFirstChild("isDead") or model:FindFirstChild("IsDead")
    if deadVal and typeof(deadVal.Value) == "boolean" and deadVal.Value == true then return true end
    return false
end

local function isTeammate(model)
    local plr = Players:GetPlayerFromCharacter(model)
    if not plr then return false end
    if player.Team and plr.Team and player.Team == plr.Team then return true end
    if player.TeamColor ~= BrickColor.new("White") and plr.TeamColor == player.TeamColor then return true end
    if not player.Neutral and not plr.Neutral and player.Team == plr.Team then return true end
    return false
end

local function isTeammatePlayer(plr)
    if not plr then return false end
    if player.Team and plr.Team and player.Team == plr.Team then return true end
    if player.TeamColor ~= BrickColor.new("White") and plr.TeamColor == player.TeamColor then return true end
    if not player.Neutral and not plr.Neutral and player.Team == plr.Team then return true end
    return false
end


--══════════════════════════════════════════════════════════════
--  HITBOX EXPANDER VARIABLES
--══════════════════════════════════════════════════════════════

local HitboxSettings = {
    Enabled = false,
    HitboxSize = 8,
    Radius = 150,
    TargetMode = "NPCs",
    HitboxPartName = "Head",
    Transparency = 0.99,
    Material = Enum.Material.Neon,
    Color = BrickColor.new("Really blue"),
    PartsPerStep = 25,
    ApplyTransparency = true,
    ApplyMaterial = true,
    ApplyColor = true,
    ApplyCanCollide = true,
    ApplyMassless = true,
}

local editedCharacters = {}
local originalHitboxData = {}


--══════════════════════════════════════════════════════════════
--  HITBOX EXPANDER LOGIC
--══════════════════════════════════════════════════════════════

local overlapParams = OverlapParams.new()
overlapParams.FilterType = Enum.RaycastFilterType.Blacklist

local function isValidTarget(character)
    if not isAlive(character) then return false end
    if isTeammate(character) then return false end
    local playerFromChar = Players:GetPlayerFromCharacter(character)
    if HitboxSettings.TargetMode == "Players" then
        return playerFromChar and playerFromChar ~= player
    elseif HitboxSettings.TargetMode == "NPCs" then
        return not playerFromChar
    elseif HitboxSettings.TargetMode == "Both" then
        return not playerFromChar or playerFromChar ~= player
    end
    return false
end

local function safeSet(obj, prop, val)
    pcall(function() obj[prop] = val end)
end

local function saveOriginal(hitbox)
    if originalHitboxData[hitbox] then return end
    local data = {}
    pcall(function() data.Size = hitbox.Size end)
    pcall(function() data.Transparency = hitbox.Transparency end)
    pcall(function() data.Material = hitbox.Material end)
    pcall(function() data.BrickColor = hitbox.BrickColor end)
    pcall(function() data.Color = hitbox.Color end)
    pcall(function() data.CanCollide = hitbox.CanCollide end)
    pcall(function() data.Massless = hitbox.Massless end)
    pcall(function() data.CanQuery = hitbox.CanQuery end)
    originalHitboxData[hitbox] = data
end

local function restoreOriginal(hitbox)
    local data = originalHitboxData[hitbox]
    if not data then return end
    if not hitbox or not hitbox.Parent then originalHitboxData[hitbox] = nil; return end
    for prop, val in pairs(data) do
        safeSet(hitbox, prop, val)
    end
    originalHitboxData[hitbox] = nil
end

local function applyHitbox(character)
    if editedCharacters[character] then return end
    if not isValidTarget(character) then return end

    local hitbox = character:FindFirstChild(HitboxSettings.HitboxPartName)
    if not hitbox or not hitbox:IsA("BasePart") then return end

    saveOriginal(hitbox)
    editedCharacters[character] = true

    for _, child in ipairs(hitbox:GetChildren()) do
        if child:IsA("Decal") or child:IsA("Texture") or child:IsA("SurfaceAppearance") then
            pcall(function() child:Destroy() end)
        end
    end

    safeSet(hitbox, "Size", Vector3.new(HitboxSettings.HitboxSize, HitboxSettings.HitboxSize, HitboxSettings.HitboxSize))

    if HitboxSettings.ApplyTransparency then
        safeSet(hitbox, "Transparency", HitboxSettings.Transparency)
    end
    if HitboxSettings.ApplyMaterial then
        safeSet(hitbox, "Material", HitboxSettings.Material)
    end
    if HitboxSettings.ApplyColor then
        safeSet(hitbox, "BrickColor", HitboxSettings.Color)
        safeSet(hitbox, "Color", HitboxSettings.Color.Color)
    end
    if HitboxSettings.ApplyCanCollide then
        safeSet(hitbox, "CanCollide", false)
    end
    if HitboxSettings.ApplyMassless then
        safeSet(hitbox, "Massless", true)
    end
    safeSet(hitbox, "CanQuery", true)
end

local function restoreAllHitboxes()
    for character, _ in pairs(editedCharacters) do
        local hitbox = character and character:FindFirstChild(HitboxSettings.HitboxPartName)
        if hitbox then restoreOriginal(hitbox) end
    end
    editedCharacters = {}
    for hitbox in pairs(originalHitboxData) do
        if not hitbox or not hitbox.Parent then originalHitboxData[hitbox] = nil end
    end
end

task.spawn(function()
    while task.wait(0.1) do
        if not HitboxSettings.Enabled then continue end

        for character, _ in pairs(editedCharacters) do
            if not character or not character.Parent or not isAlive(character) then
                local hitbox = character and character:FindFirstChild(HitboxSettings.HitboxPartName)
                if hitbox then restoreOriginal(hitbox) end
                editedCharacters[character] = nil
            end
        end

        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp then
            overlapParams.FilterDescendantsInstances = { char }
            local parts = Workspace:GetPartBoundsInRadius(hrp.Position, HitboxSettings.Radius, overlapParams)
            local processed = 0
            for i = 1, #parts do
                local model = parts[i]:FindFirstAncestorOfClass("Model")
                if model and model:FindFirstChildOfClass("Humanoid") then
                    applyHitbox(model)
                end
                processed += 1
                if processed % HitboxSettings.PartsPerStep == 0 then task.wait() end
            end
        end
    end
end)


--══════════════════════════════════════════════════════════════
--  TRIGGERBOT VARIABLES
--══════════════════════════════════════════════════════════════

local triggerBotEnabled = false
local triggerConfig = {
    HoldClick = true,
    TeamExclusionMode = "folder",
    MaxDistance = nil,
}

local mouse = player:GetMouse()
local rightDown = false
local lastX, lastY = 0, 0
local clickDelay = 0
local lastClickTime = 0
local tbClicking = false

UIS.InputBegan:Connect(function(i)
    if i.UserInputType == Enum.UserInputType.MouseButton2 then rightDown = true end
end)
UIS.InputEnded:Connect(function(i)
    if i.UserInputType == Enum.UserInputType.MouseButton2 then rightDown = false end
end)

RunService.RenderStepped:Connect(function()
    local v = UIS:GetMouseLocation()
    lastX, lastY = v.X, v.Y
end)

local function setClick(down)
    if tbClicking == down then return end
    tbClicking = down
    pcall(function() VirtualInputManager:SendMouseButtonEvent(lastX, lastY, 0, down, nil, 0) end)
end

local function spamClick()
    local now = tick()
    if now - lastClickTime < clickDelay then return end
    lastClickTime = now
    pcall(function()
        VirtualInputManager:SendMouseButtonEvent(lastX, lastY, 0, true, nil, 0)
        VirtualInputManager:SendMouseButtonEvent(lastX, lastY, 0, false, nil, 0)
    end)
end

local function inRange(model)
    local max = triggerConfig.MaxDistance
    if not max then return true end
    local char = player.Character
    if not char then return false end
    local root1 = char:FindFirstChild("HumanoidRootPart")
    if not root1 then return false end
    local root2 = model:FindFirstChild("HumanoidRootPart")
    if not root2 then
        for _, part in ipairs(model:GetChildren()) do
            if part:IsA("BasePart") then root2 = part; break end
        end
    end
    if not root2 then return false end
    return (root1.Position - root2.Position).Magnitude <= max
end

local function isMyCharacter(model) return model == player.Character end

local function isInSameParentContainer(model)
    local char = player.Character
    if not char then return false end
    return model:IsDescendantOf(char.Parent)
end

local modelCache = setmetatable({}, { __mode = "k" })

local function getCharacterModel(part)
    if not part then return end
    if modelCache[part] then return modelCache[part] end
    local current = part
    while current and current ~= Workspace do
        if current:IsA("Model") and current:FindFirstChildOfClass("Humanoid") then
            modelCache[part] = current
            return current
        end
        current = current.Parent
    end
end


--══════════════════════════════════════════════════════════════
--  PLAYER MODEL RESOLVER
--══════════════════════════════════════════════════════════════

local modelToPlayer = setmetatable({}, { __mode = "k" })
local playerNameSet = {}
local nameSetDirty = true

local function rebuildNameSet()
    playerNameSet = {}
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= player then
            playerNameSet[plr.Name:lower()] = plr
            if plr.DisplayName and #plr.DisplayName > 0 and plr.DisplayName ~= plr.Name then
                playerNameSet[plr.DisplayName:lower()] = plr
            end
            if plr.Character then modelToPlayer[plr.Character] = plr end
        end
    end
    nameSetDirty = false
end

local function tryRegisterModel(instance)
    if not instance:IsA("Model") then return end
    if nameSetDirty then rebuildNameSet() end
    local ownerPlayer = playerNameSet[instance.Name:lower()]
    if ownerPlayer then modelToPlayer[instance] = ownerPlayer end
end

Workspace.ChildAdded:Connect(tryRegisterModel)
Workspace.ChildRemoved:Connect(function(inst) if inst:IsA("Model") then modelToPlayer[inst] = nil end end)
Workspace.DescendantAdded:Connect(function(d) if d:IsA("Model") then tryRegisterModel(d) end end)
Workspace.DescendantRemoving:Connect(function(d) if d:IsA("Model") then modelToPlayer[d] = nil end end)

Players.PlayerAdded:Connect(function(plr)
    nameSetDirty = true
    plr.CharacterAdded:Connect(function(char) modelToPlayer[char] = plr end)
end)
Players.PlayerRemoving:Connect(function(plr)
    nameSetDirty = true
    for model, owner in pairs(modelToPlayer) do
        if owner == plr then modelToPlayer[model] = nil end
    end
end)
for _, plr in ipairs(Players:GetPlayers()) do
    if plr ~= player then
        plr.CharacterAdded:Connect(function(char) modelToPlayer[char] = plr end)
    end
end

task.defer(function()
    rebuildNameSet()
    for _, child in ipairs(Workspace:GetChildren()) do
        tryRegisterModel(child)
        if child:IsA("Folder") then
            for _, sub in ipairs(child:GetChildren()) do tryRegisterModel(sub) end
        end
    end
end)

local function getOwningPlayerModel(part)
    if not part then return nil, nil end
    local current = part
    while current and current ~= Workspace do
        if current:IsA("Model") then
            local ownerPlayer = modelToPlayer[current]
            if ownerPlayer then return current, ownerPlayer end
        end
        current = current.Parent
    end
    return nil, nil
end


--══════════════════════════════════════════════════════════════
--  TRIGGERBOT TARGET VALIDATION
--══════════════════════════════════════════════════════════════

local function getValidTarget(part)
    if not part then return false end

    local model = getCharacterModel(part)
    if model then
        if isMyCharacter(model) then return false end
        if not inRange(model) then return false end
        if not isAliveFast(model) then return false end
        if model:FindFirstChild("Ragdoll") or model:FindFirstChild("Ragdolled") then return false end
        if model:FindFirstChild("Dead") or model:FindFirstChild("IsDead") then return false end
        if not model:FindFirstChild("HumanoidRootPart") and Players:GetPlayerFromCharacter(model) then return false end
        local mode = triggerConfig.TeamExclusionMode
        if mode == "team" and isTeammate(model) then return false end
        if mode == "folder" and isInSameParentContainer(model) then return false end
        if mode == "players" and Players:GetPlayerFromCharacter(model) then return false end
        if model:FindFirstChildOfClass("Humanoid") then return true end
    end

    local playerModel, ownerPlayer = getOwningPlayerModel(part)
    if playerModel and ownerPlayer then
        if ownerPlayer == player then return false end
        if isMyCharacter(playerModel) then return false end
        if not inRange(playerModel) then return false end
        if isDeadCustomModel(playerModel) then return false end
        local mode = triggerConfig.TeamExclusionMode
        if mode == "team" and isTeammatePlayer(ownerPlayer) then return false end
        if mode == "folder" and isInSameParentContainer(playerModel) then return false end
        return true
    end

    return false
end

RunService.RenderStepped:Connect(function()
    if not triggerBotEnabled then
        if tbClicking then setClick(false) end
        return
    end
    if triggerConfig.HoldClick and not rightDown then
        if tbClicking then setClick(false) end
        return
    end
    if getValidTarget(mouse.Target) then
        spamClick()
    else
        if tbClicking then setClick(false) end
    end
end)


--══════════════════════════════════════════════════════════════
--  HITBOX EXPANDER PAGE
--══════════════════════════════════════════════════════════════

local HitboxPage = Window:CreatePage("Hitbox Expander")

local HBMainSection = HitboxPage:CreateSection("Main Controls")

local hitboxToggle = HBMainSection:CreateToggle("Enable Hitbox Expander", { Toggled = false }, function(value)
    HitboxSettings.Enabled = value
    if not value then restoreAllHitboxes() end
    Window:Notify("Hitbox Expander: " .. (value and "ON" or "OFF"))
end)
registerFunctionalToggle(hitboxToggle, false)

local HBConfigSection = HitboxPage:CreateSection("Hitbox Configuration")

HBConfigSection:CreateSlider("Hitbox Size", { Min = 1, Max = 50, DefaultValue = 8, Step = 1 }, function(value)
    HitboxSettings.HitboxSize = value
    restoreAllHitboxes()
end)

HBConfigSection:CreateSlider("Detection Radius", { Min = 50, Max = 500, DefaultValue = 150, Step = 10 }, function(value)
    HitboxSettings.Radius = value
end)

HBConfigSection:CreateSlider("Transparency", { Min = 0, Max = 100, DefaultValue = 99, Step = 1 }, function(value)
    HitboxSettings.Transparency = value / 100
    restoreAllHitboxes()
end)

local HBTargetSection = HitboxPage:CreateSection("Target Settings")

HBTargetSection:CreateDropdown("Target Mode", {
    List = { "NPCs", "Players", "Both" },
    Default = "NPCs",
}, function(value)
    HitboxSettings.TargetMode = value
    restoreAllHitboxes()
    Window:Notify("Target: " .. value)
end)

HBTargetSection:CreateTextbox("Hitbox Part Name", "Head", function(text)
    if text and #text > 0 then
        HitboxSettings.HitboxPartName = text
        restoreAllHitboxes()
        Window:Notify("Part: " .. text)
    end
end)

local HBPropSection = HitboxPage:CreateSection("Property Toggles")

HBPropSection:CreateToggle("Apply Transparency", { Toggled = true }, function(v)
    HitboxSettings.ApplyTransparency = v; restoreAllHitboxes()
end)

HBPropSection:CreateToggle("Apply Material", { Toggled = true }, function(v)
    HitboxSettings.ApplyMaterial = v; restoreAllHitboxes()
end)

HBPropSection:CreateToggle("Apply Color", { Toggled = true }, function(v)
    HitboxSettings.ApplyColor = v; restoreAllHitboxes()
end)

HBPropSection:CreateToggle("Apply CanCollide = False", { Toggled = true }, function(v)
    HitboxSettings.ApplyCanCollide = v; restoreAllHitboxes()
end)

HBPropSection:CreateToggle("Apply Massless = True", { Toggled = true }, function(v)
    HitboxSettings.ApplyMassless = v; restoreAllHitboxes()
end)

local HBAdvSection = HitboxPage:CreateSection("Advanced")

HBAdvSection:CreateSlider("Parts Per Step", { Min = 10, Max = 100, DefaultValue = 25, Step = 5 }, function(value)
    HitboxSettings.PartsPerStep = value
end)

HBAdvSection:CreateButton("Reset All Hitboxes", function()
    restoreAllHitboxes()
    Window:Notify("All hitboxes restored!")
end)


--══════════════════════════════════════════════════════════════
--  TRIGGERBOT PAGE
--══════════════════════════════════════════════════════════════

local TriggerPage = Window:CreatePage("TriggerBot")

local TBMainSection = TriggerPage:CreateSection("Main Controls")

local triggerToggle = TBMainSection:CreateToggle("Enable TriggerBot", { Toggled = false }, function(value)
    triggerBotEnabled = value
    Window:Notify("TriggerBot: " .. (value and "ON" or "OFF"))
end)
registerFunctionalToggle(triggerToggle, false)

local TBConfigSection = TriggerPage:CreateSection("Configuration")

TBConfigSection:CreateToggle("Hold Right-Click Mode", { Toggled = true }, function(value)
    triggerConfig.HoldClick = value
    Window:Notify("Hold Click: " .. (value and "ON" or "OFF"))
end)

TBConfigSection:CreateSlider("Click Delay (ms)", { Min = 0, Max = 100, DefaultValue = 0, Step = 1 }, function(value)
    clickDelay = value / 1000
end)

TBConfigSection:CreateSlider("Max Distance", { Min = 0, Max = 500, DefaultValue = 0, Step = 10 }, function(value)
    if value == 0 then
        triggerConfig.MaxDistance = nil
        Window:Notify("Distance: Unlimited")
    else
        triggerConfig.MaxDistance = value
        Window:Notify("Distance: " .. value .. " studs")
    end
end)

local TBTeamSection = TriggerPage:CreateSection("Team Exclusion")

TBTeamSection:CreateDropdown("Exclusion Mode", {
    List = { "folder", "team", "players", "none" },
    Default = "folder",
}, function(value)
    triggerConfig.TeamExclusionMode = value
    Window:Notify("Exclusion: " .. value)
end)


--══════════════════════════════════════════════════════════════
--  SERVER PAGE
--══════════════════════════════════════════════════════════════

local ServerPage = Window:CreatePage("Server")
local ServerSection = ServerPage:CreateSection("Server Tools")

ServerSection:CreateTextbox("Chat Message", "Type message...", function(text)
    if text and #text > 0 then Window:Notify("Message: " .. text) end
end)

ServerSection:CreateButton("Copy Server ID", function()
    if setclipboard then
        setclipboard(game.JobId)
        Window:Notify("Server ID copied!")
    else
        Window:Notify("Clipboard not supported")
    end
end)

ServerSection:CreateButton("Rejoin Server", function()
    Window:Notify("Rejoining...")
    if HUB_URL ~= "" then
        local queueCode = 'loadstring(game:HttpGet("' .. HUB_URL .. '"))()'
        pcall(function()
            if syn and syn.queue_on_teleport then
                syn.queue_on_teleport(queueCode)
            elseif queue_on_teleport then
                queue_on_teleport(queueCode)
            elseif fluxus and fluxus.queue_on_teleport then
                fluxus.queue_on_teleport(queueCode)
            end
        end)
    end
    task.wait(0.5)
    pcall(function()
        TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId)
    end)
end)

ServerSection:CreateButton("Reset Character", function()
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        player.Character.Humanoid.Health = 0
    end
    Window:Notify("Character reset!")
end)


--══════════════════════════════════════════════════════════════
--  MISC PAGE
--══════════════════════════════════════════════════════════════

local MiscPage = Window:CreatePage("Misc")

local UtilSection = MiscPage:CreateSection("Utilities")

local antiAfkToggle = UtilSection:CreateToggle("Anti-AFK", { Toggled = true }, function(value)
    Window:Notify("Anti-AFK: " .. (value and "ON" or "OFF"))
end)
registerFunctionalToggle(antiAfkToggle, true)

player.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end)

UtilSection:CreateButton("Copy Discord", function()
    if setclipboard then
        setclipboard("spookyie")
        Window:Notify("Discord copied: spookyie")
    else
        Window:Notify("Discord: spookyie")
    end
end)

UtilSection:CreateTextbox("Webhook URL", "Paste webhook...", function(url)
    Window:Notify("Webhook saved!")
end)

UtilSection:CreateDivider()

local InfoSection = MiscPage:CreateSection("Information")

InfoSection:CreateLabel("Script: MY HUB V1.0")
InfoSection:CreateLabel("Discord: spookyie")
InfoSection:CreateDivider()

InfoSection:CreateButton("Credits", function()
    Window:Notify("Made by Spooky // Discord: spookyie")
end)

InfoSection:CreateButton("Destroy GUI", function()
    pcall(function() Window:SaveConfig("Default") end)
    Window:Notify("Goodbye!")
    task.wait(1)
    Window:Destroy()
end)


--══════════════════════════════════════════════════════════════
--  CONFIG PAGE
--══════════════════════════════════════════════════════════════

local ConfigPage = Window:CreatePage("Config")
local ConfigSection = ConfigPage:CreateSection("Save & Load")

ConfigSection:CreateLabel("Save your settings to persist across sessions")
ConfigSection:CreateDivider()

local currentProfile = "Default"

ConfigSection:CreateTextbox("Profile Name", "Default", function(text)
    if text and #text > 0 then currentProfile = text end
end)

ConfigSection:CreateDivider()

ConfigSection:CreateButton("Save Config", function()
    local ok = Window:SaveConfig(currentProfile)
    Window:Notify(ok and ("Saved: " .. currentProfile) or "Save failed!")
end)

ConfigSection:CreateButton("Load Config", function()
    local ok = Window:LoadConfig(currentProfile)
    if ok then
        task.wait(0.1)
        resetFunctionalToggles()
        Window:Notify("Loaded: " .. currentProfile)
    else
        Window:Notify("No config found: " .. currentProfile)
    end
end)

ConfigSection:CreateButton("Delete Config", function()
    Window:DeleteConfig(currentProfile)
    Window:Notify("Deleted: " .. currentProfile)
end)

ConfigSection:CreateDivider()

ConfigSection:CreateButton("List Profiles", function()
    local profiles = Window:GetProfiles()
    Window:Notify(#profiles > 0 and table.concat(profiles, ", ") or "No saved profiles")
end)

ConfigSection:CreateButton("Export to Clipboard", function()
    local ok = Window:ExportConfig(currentProfile)
    Window:Notify(ok and "Copied to clipboard!" or "Export failed")
end)

ConfigSection:CreateDivider()
ConfigSection:CreateLabel(_hasFS and "Saves to: SpookyHub_Configs/" or "No file system — session only!")


--══════════════════════════════════════════════════════════════
--  INITIALIZATION
--══════════════════════════════════════════════════════════════

task.wait(0.5)

local loaded = Window:LoadConfig("Default")
if loaded then
    print("[HUB] Config loaded!")
else
    print("[HUB] No saved config — saving defaults")
    Window:SaveConfig("Default")
end

resetFunctionalToggles()

game:BindToClose(function()
    pcall(function() Window:SaveConfig("Default") end)
end)

print("[HUB] Ready!")
