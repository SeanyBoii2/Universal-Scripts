--══════════════════════════════════════════════════════════════
--  AUTO-RELOAD ON TELEPORT (Like Infinite Yield)
--══════════════════════════════════════════════════════════════

local HUB_URL = "https://raw.githubusercontent.com/SeanyBoii2/Universal-Scripts/refs/heads/main/Hitbox%20Expander%20%2B%20Triggerbot"

-- Define queueteleport function (like IY does)
local queueteleport = queue_on_teleport or (syn and syn.queue_on_teleport) or (fluxus and fluxus.queue_on_teleport)


--══════════════════════════════════════════════════════════════
--  LOAD LIBRARY
--══════════════════════════════════════════════════════════════

local Library
pcall(function()
    Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/SeanyBoii2/Z/refs/heads/main/SPOOKALICIOUS%20V4%20API/SpookaliciousV4.lua"))()
end)

if not Library then
    task.wait(0.5)
    pcall(function()
        Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/SeanyBoii2/Z/refs/heads/main/SPOOKALICIOUS%20V4%20API/SpookaliciousV4.lua"))()
    end)
end


--══════════════════════════════════════════════════════════════
--  CREATE WINDOW
--══════════════════════════════════════════════════════════════

local Window
pcall(function()
    Window = Library:CreateWindow("SPOOKALICIOUS V4", "Hitbox & TriggerBot")
end)


--══════════════════════════════════════════════════════════════
--  SERVICES
--══════════════════════════════════════════════════════════════

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local UIS = game:GetService("UserInputService")
local TeleportService = game:GetService("TeleportService")
local VirtualUser = game:GetService("VirtualUser")
local VirtualInputManager = game:GetService("VirtualInputManager")

local player = Players.LocalPlayer
local _hasFS = (typeof(writefile) == "function" and typeof(readfile) == "function")

local function sendNotification(title, text)
    for i = 1, 10 do
        local ok = pcall(function()
            StarterGui:SetCore("SendNotification", {
                Title = title, Text = text, Duration = 5,
            })
        end)
        if ok then break end
        task.wait(0.5)
    end
end

local functionalToggles = {}

local function registerFunctionalToggle(toggle, defaultState)
    table.insert(functionalToggles, { ref = toggle, default = defaultState or false })
end

local function resetFunctionalToggles()
    for _, item in ipairs(functionalToggles) do
        item.ref:Set(item.default)
    end
end


--══════════════════════════════════════════════════════════════
--  SHARED HELPERS
--══════════════════════════════════════════════════════════════

local function isAlive(character)
    if not character or not character.Parent then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    if humanoid.Health <= 0 then return false end
    local hState = humanoid:GetState()
    if hState == Enum.HumanoidStateType.Dead then return false end
    if hState == Enum.HumanoidStateType.Physics then return false end
    if character:FindFirstChild("Ragdoll") then return false end
    if character:FindFirstChild("Ragdolled") then return false end
    if character:FindFirstChild("Dead") then return false end
    if character:FindFirstChild("IsDead") then return false end
    local deadVal = character:FindFirstChild("isDead") or character:FindFirstChild("IsDead")
    if deadVal and typeof(deadVal.Value) == "boolean" and deadVal.Value == true then return false end
    if not character:FindFirstChild("HumanoidRootPart") and Players:GetPlayerFromCharacter(character) then
        return false
    end
    return true
end

local function isAliveFast(character)
    if not character or not character.Parent then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    local hState = humanoid:GetState()
    return hState ~= Enum.HumanoidStateType.Dead and hState ~= Enum.HumanoidStateType.Physics
end

local function isDeadCustomModel(model)
    if not model or not model.Parent then return true end
    local humanoid = model:FindFirstChildOfClass("Humanoid")
    if humanoid then
        if humanoid.Health <= 0 then return true end
        local hState = humanoid:GetState()
        if hState == Enum.HumanoidStateType.Dead or hState == Enum.HumanoidStateType.Physics then return true end
    end
    if model:FindFirstChild("Ragdoll") or model:FindFirstChild("Ragdolled") then return true end
    if model:FindFirstChild("Dead") or model:FindFirstChild("IsDead") then return true end
    local deadVal = model:FindFirstChild("isDead") or model:FindFirstChild("IsDead")
    if deadVal and typeof(deadVal.Value) == "boolean" and deadVal.Value == true then return true end
    return false
end

local function isTeammate(model)
    local plr = Players:GetPlayerFromCharacter(model)
    if not plr then return false end
    if player.Team and plr.Team and player.Team == plr.Team then return true end
    if player.TeamColor ~= BrickColor.new("White") and plr.TeamColor == player.TeamColor then return true end
    if not player.Neutral and not plr.Neutral and player.Team == plr.Team then return true end
    return false
end

local function isTeammatePlayer(plr)
    if not plr then return false end
    if player.Team and plr.Team and player.Team == plr.Team then return true end
    if player.TeamColor ~= BrickColor.new("White") and plr.TeamColor == player.TeamColor then return true end
    if not player.Neutral and not plr.Neutral and player.Team == plr.Team then return true end
    return false
end


--══════════════════════════════════════════════════════════════
--  HITBOX EXPANDER VARIABLES
--══════════════════════════════════════════════════════════════

local HitboxSettings = {
    Enabled = false,
    HitboxSize = 8,
    Radius = 150,
    TargetMode = "NPCs",
    HitboxPartName = "Head",
    Transparency = 0.99,
    Material = Enum.Material.Neon,
    Color = BrickColor.new("Really blue"),
    PartsPerStep = 25,
    ApplyTransparency = true,
    ApplyMaterial = true,
    ApplyColor = true,
    ApplyCanCollide = true,
    ApplyMassless = true,
    LockZAxis = true,  -- NEW: Lock Z-axis to 1
}

local editedCharacters = {}
local originalHitboxData = {}


--══════════════════════════════════════════════════════════════
--  HITBOX EXPANDER LOGIC
--══════════════════════════════════════════════════════════════

local overlapParams = OverlapParams.new()
overlapParams.FilterType = Enum.RaycastFilterType.Blacklist

local function isValidTarget(character)
    if not isAlive(character) then return false end
    if isTeammate(character) then return false end
    local playerFromChar = Players:GetPlayerFromCharacter(character)
    if HitboxSettings.TargetMode == "Players" then
        return playerFromChar and playerFromChar ~= player
    elseif HitboxSettings.TargetMode == "NPCs" then
        return not playerFromChar
    elseif HitboxSettings.TargetMode == "Both" then
        return not playerFromChar or playerFromChar ~= player
    end
    return false
end

local function safeSet(obj, prop, val)
    pcall(function() obj[prop] = val end)
end

local function saveOriginal(hitbox)
    if originalHitboxData[hitbox] then return end
    local data = {}
    pcall(function() data.Size = hitbox.Size end)
    pcall(function() data.Transparency = hitbox.Transparency end)
    pcall(function() data.Material = hitbox.Material end)
    pcall(function() data.BrickColor = hitbox.BrickColor end)
    pcall(function() data.Color = hitbox.Color end)
    pcall(function() data.CanCollide = hitbox.CanCollide end)
    pcall(function() data.Massless = hitbox.Massless end)
    pcall(function() data.CanQuery = hitbox.CanQuery end)
    originalHitboxData[hitbox] = data
end

local function restoreOriginal(hitbox)
    local data = originalHitboxData[hitbox]
    if not data then return end
    if not hitbox or not hitbox.Parent then originalHitboxData[hitbox] = nil; return end
    for prop, val in pairs(data) do
        safeSet(hitbox, prop, val)
    end
    originalHitboxData[hitbox] = nil
end

local function applyHitbox(character)
    if editedCharacters[character] then return end
    if not isValidTarget(character) then return end

    local hitbox = character:FindFirstChild(HitboxSettings.HitboxPartName)
    if not hitbox or not hitbox:IsA("BasePart") then return end

    saveOriginal(hitbox)
    editedCharacters[character] = true

    for _, child in ipairs(hitbox:GetChildren()) do
        if child:IsA("Decal") or child:IsA("Texture") or child:IsA("SurfaceAppearance") then
            pcall(function() child:Destroy() end)
        end
    end

    -- Apply hitbox size with optional Z-axis lock
    local zSize = HitboxSettings.LockZAxis and 1 or HitboxSettings.HitboxSize
    safeSet(hitbox, "Size", Vector3.new(HitboxSettings.HitboxSize, HitboxSettings.HitboxSize, zSize))

    if HitboxSettings.ApplyTransparency then
        safeSet(hitbox, "Transparency", HitboxSettings.Transparency)
    end
    if HitboxSettings.ApplyMaterial then
        safeSet(hitbox, "Material", HitboxSettings.Material)
    end
    if HitboxSettings.ApplyColor then
        safeSet(hitbox, "BrickColor", HitboxSettings.Color)
        safeSet(hitbox, "Color", HitboxSettings.Color.Color)
    end
    if HitboxSettings.ApplyCanCollide then
        safeSet(hitbox, "CanCollide", false)
    end
    if HitboxSettings.ApplyMassless then
        safeSet(hitbox, "Massless", true)
    end
    safeSet(hitbox, "CanQuery", true)
end

local function restoreAllHitboxes()
    for character, _ in pairs(editedCharacters) do
        local hitbox = character and character:FindFirstChild(HitboxSettings.HitboxPartName)
        if hitbox then restoreOriginal(hitbox) end
    end
    editedCharacters = {}
    for hitbox in pairs(originalHitboxData) do
        if not hitbox or not hitbox.Parent then originalHitboxData[hitbox] = nil end
    end
end

task.spawn(function()
    while task.wait(0.1) do
        if not HitboxSettings.Enabled then continue end

        for character, _ in pairs(editedCharacters) do
            if not character or not character.Parent or not isAlive(character) then
                local hitbox = character and character:FindFirstChild(HitboxSettings.HitboxPartName)
                if hitbox then restoreOriginal(hitbox) end
                editedCharacters[character] = nil
            end
        end

        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp then
            overlapParams.FilterDescendantsInstances = { char }
            local parts = Workspace:GetPartBoundsInRadius(hrp.Position, HitboxSettings.Radius, overlapParams)
            local processed = 0
            for i = 1, #parts do
                local model = parts[i]:FindFirstAncestorOfClass("Model")
                if model and model:FindFirstChildOfClass("Humanoid") then
                    applyHitbox(model)
                end
                processed += 1
                if processed % HitboxSettings.PartsPerStep == 0 then task.wait() end
            end
        end
    end
end)


--══════════════════════════════════════════════════════════════
--  TRIGGERBOT VARIABLES
--══════════════════════════════════════════════════════════════

local triggerBotEnabled = false
local triggerConfig = {
    HoldClick = true,
    TeamExclusionMode = "folder",
    MaxDistance = nil,
    ExclusionRadius = 5,  -- Lowered from 10 to 5 studs
    DebugMode = false,  -- NEW: Show debug info
    AggressiveMode = false,  -- NEW: Minimal validation (shoot everything)
}

local mouse = player:GetMouse()
local rightDown = false
local lastX, lastY = 0, 0
local clickDelay = 0
local lastClickTime = 0
local tbClicking = false

UIS.InputBegan:Connect(function(i)
    if i.UserInputType == Enum.UserInputType.MouseButton2 then rightDown = true end
end)
UIS.InputEnded:Connect(function(i)
    if i.UserInputType == Enum.UserInputType.MouseButton2 then rightDown = false end
end)

RunService.RenderStepped:Connect(function()
    local v = UIS:GetMouseLocation()
    lastX, lastY = v.X, v.Y
end)

local function setClick(down)
    if tbClicking == down then return end
    tbClicking = down
    pcall(function() VirtualInputManager:SendMouseButtonEvent(lastX, lastY, 0, down, nil, 0) end)
end

local function spamClick()
    local now = tick()
    if now - lastClickTime < clickDelay then return end
    lastClickTime = now
    pcall(function()
        VirtualInputManager:SendMouseButtonEvent(lastX, lastY, 0, true, nil, 0)
        VirtualInputManager:SendMouseButtonEvent(lastX, lastY, 0, false, nil, 0)
    end)
end

local function inRange(model)
    local max = triggerConfig.MaxDistance
    if not max then return true end
    local char = player.Character
    if not char then return false end
    local root1 = char:FindFirstChild("HumanoidRootPart")
    if not root1 then return false end
    local root2 = model:FindFirstChild("HumanoidRootPart")
    if not root2 then
        for _, part in ipairs(model:GetChildren()) do
            if part:IsA("BasePart") then root2 = part; break end
        end
    end
    if not root2 then return false end
    return (root1.Position - root2.Position).Magnitude <= max
end

local function isMyCharacter(model) return model == player.Character end

local function isInSameParentContainer(model)
    local char = player.Character
    if not char then return false end
    return model:IsDescendantOf(char.Parent)
end

local modelCache = setmetatable({}, { __mode = "k" })

local function getCharacterModel(part)
    if not part then return end
    if modelCache[part] then return modelCache[part] end
    local current = part
    while current and current ~= Workspace do
        if current:IsA("Model") and current:FindFirstChildOfClass("Humanoid") then
            modelCache[part] = current
            return current
        end
        current = current.Parent
    end
end


--══════════════════════════════════════════════════════════════
--  PLAYER MODEL RESOLVER
--══════════════════════════════════════════════════════════════

local modelToPlayer = setmetatable({}, { __mode = "k" })
local playerNameSet = {}
local nameSetDirty = true

local function rebuildNameSet()
    playerNameSet = {}
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= player then
            playerNameSet[plr.Name:lower()] = plr
            if plr.DisplayName and #plr.DisplayName > 0 and plr.DisplayName ~= plr.Name then
                playerNameSet[plr.DisplayName:lower()] = plr
            end
            if plr.Character then modelToPlayer[plr.Character] = plr end
        end
    end
    nameSetDirty = false
end

local function tryRegisterModel(instance)
    if not instance:IsA("Model") then return end
    if nameSetDirty then rebuildNameSet() end
    local ownerPlayer = playerNameSet[instance.Name:lower()]
    if ownerPlayer then modelToPlayer[instance] = ownerPlayer end
end

Workspace.ChildAdded:Connect(tryRegisterModel)
Workspace.ChildRemoved:Connect(function(inst) if inst:IsA("Model") then modelToPlayer[inst] = nil end end)
Workspace.DescendantAdded:Connect(function(d) if d:IsA("Model") then tryRegisterModel(d) end end)
Workspace.DescendantRemoving:Connect(function(d) if d:IsA("Model") then modelToPlayer[d] = nil end end)

Players.PlayerAdded:Connect(function(plr)
    nameSetDirty = true
    plr.CharacterAdded:Connect(function(char) modelToPlayer[char] = plr end)
end)
Players.PlayerRemoving:Connect(function(plr)
    nameSetDirty = true
    for model, owner in pairs(modelToPlayer) do
        if owner == plr then modelToPlayer[model] = nil end
    end
end)
for _, plr in ipairs(Players:GetPlayers()) do
    if plr ~= player then
        plr.CharacterAdded:Connect(function(char) modelToPlayer[char] = plr end)
    end
end

task.defer(function()
    rebuildNameSet()
    for _, child in ipairs(Workspace:GetChildren()) do
        tryRegisterModel(child)
        if child:IsA("Folder") then
            for _, sub in ipairs(child:GetChildren()) do tryRegisterModel(sub) end
        end
    end
end)

local function getOwningPlayerModel(part)
    if not part then return nil, nil end
    local current = part
    while current and current ~= Workspace do
        if current:IsA("Model") then
            local ownerPlayer = modelToPlayer[current]
            if ownerPlayer then return current, ownerPlayer end
        end
        current = current.Parent
    end
    return nil, nil
end


--══════════════════════════════════════════════════════════════
--  IMPROVED TRIGGERBOT WITH HYBRID RAYCAST + MOUSE.TARGET
--  - Uses raycast for accurate targeting through crosshair
--  - Falls back to mouse.Target for close range & partial obstruction
--  - Automatically excludes player character and held weapons
--══════════════════════════════════════════════════════════════

-- Create raycast params for triggerbot
local raycastParams = RaycastParams.new()
raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
raycastParams.IgnoreWater = true

-- Function to get all parts to exclude (player character + equipped tools)
local function getExclusionList()
    local exclusionList = {}
    local char = player.Character
    if char then
        table.insert(exclusionList, char)
        -- Also exclude any tools/weapons the player is holding
        for _, child in ipairs(char:GetChildren()) do
            if child:IsA("Tool") or child:IsA("Accoutrement") then
                table.insert(exclusionList, child)
            end
        end
    end
    return exclusionList
end

-- Function to check if a part belongs to player or is too close (weapon exclusion)
local function isPartTooClose(part)
    if not part or not part:IsA("BasePart") then return false end
    local char = player.Character
    if not char then return false end
    
    -- Primary check: Is this part literally part of our character or held items?
    if part:IsDescendantOf(char) then 
        if triggerConfig.DebugMode then print("[TB] Part is descendant of player") end
        return true 
    end
    
    -- Secondary check: Is this part VERY close? (only for extremely close parts)
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if hrp then
        local distance = (part.Position - hrp.Position).Magnitude
        if distance < triggerConfig.ExclusionRadius then
            if triggerConfig.DebugMode then print("[TB] Part within exclusion radius: " .. distance) end
            return true
        end
    end
    
    return false
end

-- Function to get target model from a part
local function getTargetModelFromPart(hitPart)
    if not hitPart then 
        if triggerConfig.DebugMode then print("[TB] No hitPart") end
        return nil 
    end
    
    if triggerConfig.DebugMode then print("[TB] Checking part: " .. hitPart.Name) end
    
    -- Exclude parts that are too close (likely our own weapon)
    if isPartTooClose(hitPart) then 
        if triggerConfig.DebugMode then print("[TB] Part too close/own part") end
        return nil 
    end
    
    -- Find the model this part belongs to
    local model = getCharacterModel(hitPart)
    if model then 
        if triggerConfig.DebugMode then print("[TB] Found character model: " .. model.Name) end
        return model
    end
    
    -- Try getting player model
    local playerModel, ownerPlayer = getOwningPlayerModel(hitPart)
    if playerModel and ownerPlayer then
        if triggerConfig.DebugMode then print("[TB] Found player model: " .. playerModel.Name .. " (owner: " .. ownerPlayer.Name .. ")") end
        return playerModel
    end
    
    if triggerConfig.DebugMode then print("[TB] No valid model found for part") end
    return nil
end

-- HYBRID: Try raycast first, then fallback to mouse.Target
local function getHybridTarget()
    local camera = Workspace.CurrentCamera
    if not camera then 
        if triggerConfig.DebugMode then print("[TB] No camera, using mouse.Target") end
        return mouse.Target and getTargetModelFromPart(mouse.Target) 
    end
    
    -- Update exclusion list
    raycastParams.FilterDescendantsInstances = getExclusionList()
    
    -- TRY 1: Raycast from camera center (best for accuracy)
    local ray = camera:ScreenPointToRay(lastX, lastY)
    local maxDistance = triggerConfig.MaxDistance or 1000
    local result = Workspace:Raycast(ray.Origin, ray.Direction * maxDistance, raycastParams)
    
    if result and result.Instance then
        if triggerConfig.DebugMode then print("[TB] Raycast hit: " .. result.Instance.Name) end
        local model = getTargetModelFromPart(result.Instance)
        if model then 
            if triggerConfig.DebugMode then print("[TB] Raycast found model: " .. model.Name) end
            return model 
        end
    else
        if triggerConfig.DebugMode then print("[TB] Raycast missed") end
    end
    
    -- TRY 2: Fallback to mouse.Target (handles close range + partial obstruction)
    if mouse.Target then
        if triggerConfig.DebugMode then print("[TB] Mouse.Target: " .. mouse.Target.Name) end
        local model = getTargetModelFromPart(mouse.Target)
        if model then 
            if triggerConfig.DebugMode then print("[TB] Mouse found model: " .. model.Name) end
            return model 
        end
    else
        if triggerConfig.DebugMode then print("[TB] No mouse.Target") end
    end
    
    return nil
end

-- Improved target validation for raycast-based targeting
local function isValidRaycastTarget(model)
    if not model then 
        if triggerConfig.DebugMode then print("[TB] No model") end
        return false 
    end
    
    -- Exclude own character (ALWAYS)
    if isMyCharacter(model) then 
        if triggerConfig.DebugMode then print("[TB] Own character") end
        return false 
    end
    
    -- AGGRESSIVE MODE: Minimal checks - shoot anything with a humanoid
    if triggerConfig.AggressiveMode then
        local humanoid = model:FindFirstChildOfClass("Humanoid")
        if humanoid then
            if triggerConfig.DebugMode then print("[TB] ✓ AGGRESSIVE MODE: " .. model.Name) end
            return true
        else
            if triggerConfig.DebugMode then print("[TB] No humanoid (aggressive mode)") end
            return false
        end
    end
    
    -- NORMAL MODE: Standard validation
    -- Check if alive (simplified check)
    local humanoid = model:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health <= 0 then 
        if triggerConfig.DebugMode then print("[TB] Dead (health <= 0)") end
        return false 
    end
    
    -- Check distance if configured
    if not inRange(model) then 
        if triggerConfig.DebugMode then print("[TB] Out of range") end
        return false 
    end
    
    -- Apply team exclusion modes
    local mode = triggerConfig.TeamExclusionMode
    
    if mode == "team" then
        if isTeammate(model) then 
            if triggerConfig.DebugMode then print("[TB] Teammate (team mode)") end
            return false 
        end
    elseif mode == "folder" then
        if isInSameParentContainer(model) then 
            if triggerConfig.DebugMode then print("[TB] Same folder") end
            return false 
        end
    elseif mode == "players" then
        if Players:GetPlayerFromCharacter(model) then 
            if triggerConfig.DebugMode then print("[TB] Is player (players mode)") end
            return false 
        end
    end
    -- mode == "none" allows all targets
    
    if triggerConfig.DebugMode then 
        print("[TB] ✓ VALID TARGET: " .. model.Name) 
    end
    
    return true
end

-- Main triggerbot loop with hybrid raycast + mouse.Target
RunService.RenderStepped:Connect(function()
    if not triggerBotEnabled then
        if tbClicking then setClick(false) end
        return
    end
    
    if triggerConfig.HoldClick and not rightDown then
        if tbClicking then setClick(false) end
        return
    end
    
    -- Use hybrid system: raycast + mouse.Target fallback
    local targetModel = getHybridTarget()
    
    if targetModel and isValidRaycastTarget(targetModel) then
        spamClick()
    else
        if tbClicking then setClick(false) end
    end
end)


--══════════════════════════════════════════════════════════════
--  HITBOX EXPANDER PAGE
--══════════════════════════════════════════════════════════════

local HitboxPage = Window:CreatePage("Hitbox Expander")

local HBMainSection = HitboxPage:CreateSection("Main Controls")

local hitboxToggle = HBMainSection:CreateToggle("Enable Hitbox Expander", { Toggled = false }, function(value)
    HitboxSettings.Enabled = value
    if not value then restoreAllHitboxes() end
    Window:Notify("Hitbox Expander: " .. (value and "ON" or "OFF"))
end)
registerFunctionalToggle(hitboxToggle, false)

local HBConfigSection = HitboxPage:CreateSection("Hitbox Configuration")

HBConfigSection:CreateSlider("Hitbox Size", { Min = 1, Max = 50, DefaultValue = 8, Step = 1 }, function(value)
    HitboxSettings.HitboxSize = value
    restoreAllHitboxes()
end)

HBConfigSection:CreateSlider("Detection Radius", { Min = 50, Max = 500, DefaultValue = 150, Step = 10 }, function(value)
    HitboxSettings.Radius = value
end)

HBConfigSection:CreateSlider("Transparency", { Min = 0, Max = 100, DefaultValue = 99, Step = 1 }, function(value)
    HitboxSettings.Transparency = value / 100
    restoreAllHitboxes()
end)

local HBTargetSection = HitboxPage:CreateSection("Target Settings")

HBTargetSection:CreateDropdown("Target Mode", {
    List = { "NPCs", "Players", "Both" },
    Default = "NPCs",
}, function(value)
    HitboxSettings.TargetMode = value
    restoreAllHitboxes()
    Window:Notify("Target: " .. value)
end)

HBTargetSection:CreateTextbox("Hitbox Part Name", "Head", function(text)
    if text and #text > 0 then
        HitboxSettings.HitboxPartName = text
        restoreAllHitboxes()
        Window:Notify("Part: " .. text)
    end
end)

local HBPropSection = HitboxPage:CreateSection("Property Toggles")

HBPropSection:CreateToggle("Lock Z-Axis to 1", { Toggled = true }, function(v)
    HitboxSettings.LockZAxis = v; restoreAllHitboxes()
    Window:Notify("Z-Axis Lock: " .. (v and "ON" or "OFF"))
end)

HBPropSection:CreateToggle("Apply Transparency", { Toggled = true }, function(v)
    HitboxSettings.ApplyTransparency = v; restoreAllHitboxes()
end)

HBPropSection:CreateToggle("Apply Material", { Toggled = true }, function(v)
    HitboxSettings.ApplyMaterial = v; restoreAllHitboxes()
end)

HBPropSection:CreateToggle("Apply Color", { Toggled = true }, function(v)
    HitboxSettings.ApplyColor = v; restoreAllHitboxes()
end)

HBPropSection:CreateToggle("Apply CanCollide = False", { Toggled = true }, function(v)
    HitboxSettings.ApplyCanCollide = v; restoreAllHitboxes()
end)

HBPropSection:CreateToggle("Apply Massless = True", { Toggled = true }, function(v)
    HitboxSettings.ApplyMassless = v; restoreAllHitboxes()
end)

local HBAdvSection = HitboxPage:CreateSection("Advanced")

HBAdvSection:CreateSlider("Parts Per Step", { Min = 10, Max = 100, DefaultValue = 25, Step = 5 }, function(value)
    HitboxSettings.PartsPerStep = value
end)

HBAdvSection:CreateButton("Reset All Hitboxes", function()
    restoreAllHitboxes()
    Window:Notify("All hitboxes restored!")
end)


--══════════════════════════════════════════════════════════════
--  TRIGGERBOT PAGE
--══════════════════════════════════════════════════════════════

local TriggerPage = Window:CreatePage("TriggerBot")

local TBMainSection = TriggerPage:CreateSection("Main Controls")

local triggerToggle = TBMainSection:CreateToggle("Enable TriggerBot", { Toggled = false }, function(value)
    triggerBotEnabled = value
    Window:Notify("TriggerBot: " .. (value and "ON" or "OFF"))
end)
registerFunctionalToggle(triggerToggle, false)

local TBConfigSection = TriggerPage:CreateSection("Configuration")

TBConfigSection:CreateToggle("Hold Right-Click Mode", { Toggled = true }, function(value)
    triggerConfig.HoldClick = value
    Window:Notify("Hold Click: " .. (value and "ON" or "OFF"))
end)

TBConfigSection:CreateSlider("Click Delay (ms)", { Min = 0, Max = 100, DefaultValue = 0, Step = 1 }, function(value)
    clickDelay = value / 1000
end)

TBConfigSection:CreateSlider("Max Distance", { Min = 0, Max = 500, DefaultValue = 0, Step = 10 }, function(value)
    if value == 0 then
        triggerConfig.MaxDistance = nil
        Window:Notify("Distance: Unlimited")
    else
        triggerConfig.MaxDistance = value
        Window:Notify("Distance: " .. value .. " studs")
    end
end)

TBConfigSection:CreateSlider("Exclusion Radius", { Min = 3, Max = 20, DefaultValue = 5, Step = 1 }, function(value)
    triggerConfig.ExclusionRadius = value
    Window:Notify("Exclusion Radius: " .. value .. " studs")
end)

TBConfigSection:CreateToggle("Debug Mode", { Toggled = false }, function(value)
    triggerConfig.DebugMode = value
    Window:Notify("Debug Mode: " .. (value and "ON (check console)" or "OFF"))
end)

TBConfigSection:CreateToggle("Aggressive Mode", { Toggled = false }, function(value)
    triggerConfig.AggressiveMode = value
    Window:Notify("Aggressive: " .. (value and "ON (shoots everything!)" or "OFF"))
end)

TBConfigSection:CreateDivider()
TBConfigSection:CreateLabel("Uses hybrid targeting:")
TBConfigSection:CreateLabel("Raycast + Mouse fallback for close range")
TBConfigSection:CreateDivider()
TBConfigSection:CreateLabel("Not working? Try:")
TBConfigSection:CreateLabel("1. Enable Debug Mode (check console)")
TBConfigSection:CreateLabel("2. Try Aggressive Mode")
TBConfigSection:CreateLabel("3. Change Exclusion Mode to 'none'")

local TBTeamSection = TriggerPage:CreateSection("Team Exclusion")

TBTeamSection:CreateDropdown("Exclusion Mode", {
    List = { "folder", "team", "players", "none" },
    Default = "folder",
}, function(value)
    triggerConfig.TeamExclusionMode = value
    Window:Notify("Exclusion: " .. value)
end)


--══════════════════════════════════════════════════════════════
--  SERVER PAGE
--══════════════════════════════════════════════════════════════

local ServerPage = Window:CreatePage("Server")
local ServerSection = ServerPage:CreateSection("Server Tools")

ServerSection:CreateTextbox("Chat Message", "Type message...", function(text)
    if text and #text > 0 then Window:Notify("Message: " .. text) end
end)

ServerSection:CreateButton("Copy Server ID", function()
    if setclipboard then
        setclipboard(game.JobId)
        Window:Notify("Server ID copied!")
    else
        Window:Notify("Clipboard not supported")
    end
end)

ServerSection:CreateButton("Rejoin Server", function()
    if queueteleport and HUB_URL ~= "" then
        local queueCode = 'loadstring(game:HttpGet("' .. HUB_URL .. '"))()'
        pcall(function()
            queueteleport(queueCode)
        end)
    end
    
    task.wait(0.3)
    
    pcall(function()
        TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId)
    end)
end)

ServerSection:CreateButton("Server Hop", function()
    Window:Notify("Finding new server...")
    
    if queueteleport and HUB_URL ~= "" then
        local queueCode = 'loadstring(game:HttpGet("' .. HUB_URL .. '"))()'
        pcall(function()
            queueteleport(queueCode)
        end)
    end
    
    local success, result = pcall(function()
        local servers = game:GetService("HttpService"):JSONDecode(
            game:HttpGet("https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100")
        )
        
        if servers and servers.data then
            for _, server in pairs(servers.data) do
                if server.id ~= game.JobId and server.playing < server.maxPlayers then
                    Window:Notify("Joining new server...")
                    task.wait(0.5)
                    TeleportService:TeleportToPlaceInstance(game.PlaceId, server.id)
                    return
                end
            end
            Window:Notify("No other servers available")
        else
            Window:Notify("Could not fetch servers")
        end
    end)
    
    if not success then
        Window:Notify("Server hop failed!")
    end
end)

ServerSection:CreateDivider()

-- ═══════════════════════════════════════════════════════════
--  SERVER SAVER SYSTEM
-- ═══════════════════════════════════════════════════════════
local HttpService = game:GetService("HttpService")
local FILE_NAME = "SavedServers_SpookaliciousHub.json"

local function saveServerData(data)
    if writefile then
        writefile(FILE_NAME, HttpService:JSONEncode(data))
    end
end

local function loadServerData()
    if isfile and isfile(FILE_NAME) then
        local success, result = pcall(function()
            return HttpService:JSONDecode(readfile(FILE_NAME))
        end)
        if success then return result end
    end
    return {}
end

local serverMap = {}
local selectedServer = nil

local function buildServerList()
    local data = loadServerData()
    local names = {}
    serverMap = {}

    for i, v in ipairs(data) do
        local displayName = "#" .. i .. " | " .. v.Time
        table.insert(names, displayName)
        serverMap[displayName] = i
    end

    return data, names
end

local serverData, initialServerNames = buildServerList()

local savedServerDropdown = ServerSection:CreateDropdown("Saved Servers", {
    List = initialServerNames,
    Default = initialServerNames[1] or "None"
}, function(value)
    selectedServer = value
end)

selectedServer = initialServerNames[1]

ServerSection:CreateButton("Save Current Server", function()
    local data = loadServerData()
    local entry = {
        JobId = game.JobId,
        PlaceId = game.PlaceId,
        Time = os.date("%H:%M | %d %b")
    }
    table.insert(data, 1, entry)
    if #data > 20 then table.remove(data, 21) end
    saveServerData(data)

    local _, names = buildServerList()
    savedServerDropdown:Refresh(names)
    selectedServer = names[1]

    Window:Notify("Server Saved!")
end)

ServerSection:CreateButton("Join Saved Server", function()
    if not selectedServer or selectedServer == "None" then
        Window:Notify("No server selected!")
        return
    end

    local index = serverMap[selectedServer]
    if not index then
        Window:Notify("Server not found! Try refreshing.")
        return
    end

    local data = loadServerData()
    local server = data[index]

    if not server then
        Window:Notify("Server data missing!")
        return
    end

    if queueteleport and HUB_URL ~= "" then
        local queueCode = 'loadstring(game:HttpGet("' .. HUB_URL .. '"))()'
        pcall(function()
            queueteleport(queueCode)
        end)
    end

    Window:Notify("Joining: " .. server.Time)
    task.wait(0.3)
    TeleportService:TeleportToPlaceInstance(server.PlaceId, server.JobId, player)
end)

ServerSection:CreateButton("Refresh Server List", function()
    local data, names = buildServerList()
    savedServerDropdown:Refresh(names)
    if #names > 0 then
        selectedServer = names[1]
    end
    Window:Notify("Found " .. #data .. " saved servers")
end)

ServerSection:CreateButton("Clear Server History", function()
    saveServerData({})
    serverMap = {}
    selectedServer = nil
    savedServerDropdown:Refresh({})
    Window:Notify("Server history cleared!")
end)

ServerSection:CreateDivider()

ServerSection:CreateButton("Reset Character", function()
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        player.Character.Humanoid.Health = 0
    end
    Window:Notify("Character reset!")
end)


--══════════════════════════════════════════════════════════════
--  MISC PAGE
--══════════════════════════════════════════════════════════════

local MiscPage = Window:CreatePage("Misc")

local UtilSection = MiscPage:CreateSection("Utilities")

local antiAfkToggle = UtilSection:CreateToggle("Anti-AFK", { Toggled = true }, function(value)
    Window:Notify("Anti-AFK: " .. (value and "ON" or "OFF"))
end)
registerFunctionalToggle(antiAfkToggle, true)

player.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end)

UtilSection:CreateButton("Copy Discord", function()
    if setclipboard then
        setclipboard("spookyie")
        Window:Notify("Discord copied: spookyie")
    else
        Window:Notify("Discord: spookyie")
    end
end)

UtilSection:CreateButton("Load Spookalicious Hub", function()
    Window:Notify("Loading Spookalicious Hub...")
    pcall(function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/SeanyBoii2/Z/refs/heads/main/SPOOKALICIOUS%20V4%20API/Spooky%20Hub%20Official"))()
    end)
end)

UtilSection:CreateTextbox("Webhook URL", "Paste webhook...", function(url)
    Window:Notify("Webhook saved!")
end)

UtilSection:CreateDivider()

local InfoSection = MiscPage:CreateSection("Information")

InfoSection:CreateLabel("Script: Hitbox & TriggerBot V1.0")
InfoSection:CreateLabel("Discord: spookyie")
InfoSection:CreateDivider()

InfoSection:CreateButton("Credits", function()
    Window:Notify("Made by Spooky // Discord: spookyie")
end)

InfoSection:CreateButton("Destroy GUI", function()
    pcall(function() Window:SaveConfig("Default") end)
    Window:Notify("Goodbye!")
    task.wait(1)
    Window:Destroy()
end)


--══════════════════════════════════════════════════════════════
--  CONFIG PAGE
--══════════════════════════════════════════════════════════════

local ConfigPage = Window:CreatePage("Config")
local ConfigSection = ConfigPage:CreateSection("Save & Load")

ConfigSection:CreateLabel("Save your settings to persist across sessions")
ConfigSection:CreateDivider()

local currentProfile = "Default"

ConfigSection:CreateTextbox("Profile Name", "Default", function(text)
    if text and #text > 0 then currentProfile = text end
end)

ConfigSection:CreateDivider()

ConfigSection:CreateButton("Save Config", function()
    local ok = Window:SaveConfig(currentProfile)
    Window:Notify(ok and ("Saved: " .. currentProfile) or "Save failed!")
end)

ConfigSection:CreateButton("Load Config", function()
    local ok = Window:LoadConfig(currentProfile)
    if ok then
        task.wait(0.1)
        resetFunctionalToggles()
        Window:Notify("Loaded: " .. currentProfile)
    else
        Window:Notify("No config found: " .. currentProfile)
    end
end)

ConfigSection:CreateButton("Delete Config", function()
    Window:DeleteConfig(currentProfile)
    Window:Notify("Deleted: " .. currentProfile)
end)

ConfigSection:CreateDivider()

ConfigSection:CreateButton("List Profiles", function()
    local profiles = Window:GetProfiles()
    Window:Notify(#profiles > 0 and table.concat(profiles, ", ") or "No saved profiles")
end)

ConfigSection:CreateButton("Export to Clipboard", function()
    local ok = Window:ExportConfig(currentProfile)
    Window:Notify(ok and "Copied to clipboard!" or "Export failed")
end)

ConfigSection:CreateDivider()
ConfigSection:CreateLabel(_hasFS and "Saves to: SpookyHub_Configs/" or "No file system — session only!")


--══════════════════════════════════════════════════════════════
--  INITIALIZATION
--══════════════════════════════════════════════════════════════

task.wait(0.5)

local loaded = Window:LoadConfig("Default")
if loaded then
    print("[HUB] Config loaded!")
else
    print("[HUB] No saved config — saving defaults")
    Window:SaveConfig("Default")
end

resetFunctionalToggles()

game:BindToClose(function()
    pcall(function() Window:SaveConfig("Default") end)
end)

print("[HUB] Ready!")
